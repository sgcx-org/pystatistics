"""
R validation tests for survival analysis.

Compares pystatistics survival results against R's survival package.
Fixtures are generated by:
    python tests/fixtures/generate_survival_fixtures.py
    Rscript tests/fixtures/run_r_survival_validation.R

These tests require the R results files (surv_*_r_results.json).
"""

import json
from pathlib import Path

import numpy as np
import pytest
from numpy.testing import assert_allclose

from pystatistics.survival import coxph, kaplan_meier, survdiff


FIXTURES_DIR = Path(__file__).resolve().parent.parent / "fixtures"


def _to_float_array(values) -> np.ndarray:
    """Convert R JSON values to float array, handling NaN/NA strings."""
    result = []
    for v in values:
        if isinstance(v, str):
            result.append(np.nan)
        else:
            result.append(float(v))
    return np.array(result, dtype=np.float64)


def _load_fixture(name: str) -> tuple[dict, dict]:
    """Load meta and R results for a fixture."""
    meta_path = FIXTURES_DIR / f"surv_{name}_meta.json"
    r_path = FIXTURES_DIR / f"surv_{name}_r_results.json"

    if not meta_path.exists():
        pytest.skip(f"Fixture meta not found: {meta_path}")
    if not r_path.exists():
        pytest.skip(f"R results not found: {r_path}")

    with open(meta_path) as f:
        meta = json.load(f)
    with open(r_path) as f:
        r_results = json.load(f)

    return meta, r_results


# ═══════════════════════════════════════════════════════════════════════
# Kaplan-Meier validation
# ═══════════════════════════════════════════════════════════════════════

KM_FIXTURES = [
    "km_basic", "km_no_cens", "km_heavy_cens", "km_ties",
    "km_plain_ci", "km_loglog_ci",
]


@pytest.mark.parametrize("fixture_name", KM_FIXTURES)
class TestKMValidation:
    """Kaplan-Meier validation against R survival::survfit()."""

    def test_survival_matches_r(self, fixture_name):
        """S(t) matches R exactly."""
        meta, r = _load_fixture(fixture_name)
        result = kaplan_meier(
            meta["time"], meta["event"],
            conf_level=meta["conf_level"],
            conf_type=meta["conf_type"],
        )

        r_surv = np.array(r["survival"])
        assert_allclose(result.survival, r_surv, rtol=1e-10,
                       err_msg=f"S(t) mismatch for {fixture_name}")

    def test_event_times_match_r(self, fixture_name):
        """Event times match R."""
        meta, r = _load_fixture(fixture_name)
        result = kaplan_meier(
            meta["time"], meta["event"],
            conf_level=meta["conf_level"],
            conf_type=meta["conf_type"],
        )

        r_times = np.array(r["time"])
        assert_allclose(result.time, r_times, rtol=1e-10,
                       err_msg=f"Event times mismatch for {fixture_name}")

    def test_n_risk_matches_r(self, fixture_name):
        """Number at risk matches R."""
        meta, r = _load_fixture(fixture_name)
        result = kaplan_meier(
            meta["time"], meta["event"],
            conf_level=meta["conf_level"],
            conf_type=meta["conf_type"],
        )

        r_risk = np.array(r["n_risk"])
        assert_allclose(result.n_risk, r_risk, rtol=1e-10,
                       err_msg=f"n.risk mismatch for {fixture_name}")

    def test_se_matches_r(self, fixture_name):
        """Standard errors match R."""
        meta, r = _load_fixture(fixture_name)
        result = kaplan_meier(
            meta["time"], meta["event"],
            conf_level=meta["conf_level"],
            conf_type=meta["conf_type"],
        )

        r_se = _to_float_array(r["se"])
        # Only compare where R gives finite SE
        valid = np.isfinite(r_se)
        if np.any(valid):
            assert_allclose(result.se[valid], r_se[valid], rtol=1e-6,
                           err_msg=f"SE mismatch for {fixture_name}")

    def test_ci_matches_r(self, fixture_name):
        """Confidence intervals match R."""
        meta, r = _load_fixture(fixture_name)
        result = kaplan_meier(
            meta["time"], meta["event"],
            conf_level=meta["conf_level"],
            conf_type=meta["conf_type"],
        )

        r_lower = _to_float_array(r["ci_lower"])
        r_upper = _to_float_array(r["ci_upper"])

        # Handle NaN in R (from S=0 or edge cases)
        valid = np.isfinite(r_lower) & np.isfinite(r_upper)

        if np.any(valid):
            assert_allclose(
                result.ci_lower[valid], r_lower[valid], rtol=1e-6,
                err_msg=f"CI lower mismatch for {fixture_name}",
            )
            assert_allclose(
                result.ci_upper[valid], r_upper[valid], rtol=1e-6,
                err_msg=f"CI upper mismatch for {fixture_name}",
            )


# ═══════════════════════════════════════════════════════════════════════
# Log-rank test validation
# ═══════════════════════════════════════════════════════════════════════

LR_FIXTURES = ["lr_two_group", "lr_three_group", "lr_peto"]


@pytest.mark.parametrize("fixture_name", LR_FIXTURES)
class TestLogRankValidation:
    """Log-rank test validation against R survival::survdiff()."""

    def test_statistic_matches_r(self, fixture_name):
        """Chi-squared statistic matches R."""
        meta, r = _load_fixture(fixture_name)
        result = survdiff(
            meta["time"], meta["event"], meta["group"],
            rho=meta["rho"],
        )

        r_stat = r["statistic"]
        assert result.statistic == pytest.approx(r_stat, rel=1e-4),\
            f"Chi-sq mismatch for {fixture_name}: {result.statistic} vs {r_stat}"

    def test_p_value_matches_r(self, fixture_name):
        """p-value matches R."""
        meta, r = _load_fixture(fixture_name)
        result = survdiff(
            meta["time"], meta["event"], meta["group"],
            rho=meta["rho"],
        )

        r_p = r["p_value"]
        assert result.p_value == pytest.approx(r_p, rel=1e-3, abs=1e-6),\
            f"p-value mismatch for {fixture_name}: {result.p_value} vs {r_p}"

    def test_expected_matches_r(self, fixture_name):
        """Expected events match R."""
        meta, r = _load_fixture(fixture_name)
        result = survdiff(
            meta["time"], meta["event"], meta["group"],
            rho=meta["rho"],
        )

        r_expected = np.array(r["expected"])
        assert_allclose(result.expected, r_expected, rtol=1e-4,
                       err_msg=f"Expected mismatch for {fixture_name}")


# ═══════════════════════════════════════════════════════════════════════
# Cox PH validation
# ═══════════════════════════════════════════════════════════════════════

COX_FIXTURES = ["cox_single", "cox_two_cov", "cox_breslow", "cox_ties"]


@pytest.mark.parametrize("fixture_name", COX_FIXTURES)
class TestCoxPHValidation:
    """Cox PH validation against R survival::coxph()."""

    def test_coefficients_match_r(self, fixture_name):
        """Coefficients match R."""
        meta, r = _load_fixture(fixture_name)
        X = np.array(meta["X"], dtype=np.float64)
        result = coxph(
            meta["time"], meta["event"], X,
            ties=meta["ties"],
        )

        r_coef = np.atleast_1d(np.array(r["coefficients"]))
        assert_allclose(result.coefficients, r_coef, rtol=1e-4,
                       err_msg=f"Coef mismatch for {fixture_name}")

    def test_standard_errors_match_r(self, fixture_name):
        """Standard errors match R."""
        meta, r = _load_fixture(fixture_name)
        X = np.array(meta["X"], dtype=np.float64)
        result = coxph(
            meta["time"], meta["event"], X,
            ties=meta["ties"],
        )

        r_se = np.atleast_1d(np.array(r["standard_errors"]))
        assert_allclose(result.standard_errors, r_se, rtol=1e-3,
                       err_msg=f"SE mismatch for {fixture_name}")

    def test_hazard_ratios_match_r(self, fixture_name):
        """Hazard ratios match R."""
        meta, r = _load_fixture(fixture_name)
        X = np.array(meta["X"], dtype=np.float64)
        result = coxph(
            meta["time"], meta["event"], X,
            ties=meta["ties"],
        )

        r_hr = np.atleast_1d(np.array(r["hazard_ratios"]))
        assert_allclose(result.hazard_ratios, r_hr, rtol=1e-4,
                       err_msg=f"HR mismatch for {fixture_name}")

    def test_loglik_matches_r(self, fixture_name):
        """Log-likelihoods match R."""
        meta, r = _load_fixture(fixture_name)
        X = np.array(meta["X"], dtype=np.float64)
        result = coxph(
            meta["time"], meta["event"], X,
            ties=meta["ties"],
        )

        # Null log-likelihood
        r_ll_null = r["loglik_null"]
        assert result.loglik[0] == pytest.approx(r_ll_null, rel=1e-4),\
            f"Null loglik mismatch for {fixture_name}"

        # Model log-likelihood
        r_ll_model = r["loglik_model"]
        assert result.loglik[1] == pytest.approx(r_ll_model, rel=1e-4),\
            f"Model loglik mismatch for {fixture_name}"

    def test_concordance_matches_r(self, fixture_name):
        """Concordance matches R (approximately)."""
        meta, r = _load_fixture(fixture_name)
        X = np.array(meta["X"], dtype=np.float64)
        result = coxph(
            meta["time"], meta["event"], X,
            ties=meta["ties"],
        )

        r_conc = r["concordance"]
        # Concordance can vary slightly due to tie-breaking
        assert result.concordance == pytest.approx(r_conc, abs=0.05),\
            f"Concordance mismatch for {fixture_name}: {result.concordance} vs {r_conc}"

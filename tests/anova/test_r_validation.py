"""
R validation tests for ANOVA.

Compares pystatistics ANOVA results against R's aov(), car::Anova(),
TukeyHSD(), car::leveneTest(), and base R repeated-measures aov().

Fixtures generated by:
    python tests/fixtures/generate_anova_fixtures.py
    Rscript tests/fixtures/run_r_anova_validation.R

These tests require the R results files (anova_*_r_results.json).
"""

import json
from pathlib import Path

import numpy as np
import pytest
from numpy.testing import assert_allclose

from pystatistics.anova import (
    anova,
    anova_oneway,
    anova_posthoc,
    anova_rm,
    levene_test,
)


FIXTURES_DIR = Path(__file__).resolve().parent.parent / "fixtures"


def _load_fixture(name: str) -> tuple[dict, dict]:
    """Load meta and R results for a fixture."""
    meta_path = FIXTURES_DIR / f"anova_{name}_meta.json"
    r_path = FIXTURES_DIR / f"anova_{name}_r_results.json"

    if not meta_path.exists():
        pytest.skip(f"Fixture meta not found: {meta_path}")
    if not r_path.exists():
        pytest.skip(f"R results not found: {r_path}")

    with open(meta_path) as f:
        meta = json.load(f)
    with open(r_path) as f:
        r_results = json.load(f)

    # Skip if R results are empty (missing package)
    if isinstance(r_results, list) and len(r_results) == 0:
        pytest.skip("R results empty (missing R package)")

    return meta, r_results


# ═══════════════════════════════════════════════════════════════════════
# One-way ANOVA validation
# ═══════════════════════════════════════════════════════════════════════

ONEWAY_FIXTURES = ["oneway_balanced", "oneway_unbalanced"]


@pytest.mark.parametrize("fixture_name", ONEWAY_FIXTURES)
class TestOneWayValidation:
    """One-way ANOVA validation against R's anova(lm(...))."""

    def test_type1_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        # R's type1_ss has [group_ss, residual_ss]
        assert_allclose(
            result.table[0].sum_sq, r["type1_ss"][0], rtol=1e-10,
            err_msg=f"Type I SS mismatch for {fixture_name}",
        )

    def test_type1_f_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        assert_allclose(
            result.table[0].f_value, r["type1_f"], rtol=1e-10,
            err_msg=f"Type I F mismatch for {fixture_name}",
        )

    def test_type1_p_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        assert_allclose(
            result.table[0].p_value, r["type1_p"], rtol=1e-8,
            err_msg=f"Type I p mismatch for {fixture_name}",
        )

    def test_type1_df_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        assert result.table[0].df == r["type1_df"][0]
        assert result.table[1].df == r["type1_df"][1]

    def test_type1_ms_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        assert_allclose(
            result.table[0].mean_sq, r["type1_ms"][0], rtol=1e-10,
        )
        assert_allclose(
            result.table[1].mean_sq, r["type1_ms"][1], rtol=1e-10,
        )

    def test_residual_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova_oneway(meta["y"], meta["group"], ss_type=1)
        assert_allclose(
            result.residual_ss, r["residual_ss"], rtol=1e-10,
        )

    def test_type2_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        if "type2_ss_group" not in r:
            pytest.skip("Type II results not available from R")
        result = anova_oneway(meta["y"], meta["group"], ss_type=2)
        assert_allclose(
            result.table[0].sum_sq, r["type2_ss_group"], rtol=1e-10,
        )

    def test_type3_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        if "type3_ss_group" not in r:
            pytest.skip("Type III results not available from R")
        result = anova_oneway(meta["y"], meta["group"], ss_type=3)
        assert_allclose(
            result.table[0].sum_sq, r["type3_ss_group"], rtol=1e-10,
        )


# ═══════════════════════════════════════════════════════════════════════
# Factorial ANOVA validation
# ═══════════════════════════════════════════════════════════════════════

FACTORIAL_FIXTURES = ["twoway_balanced", "twoway_unbalanced"]


@pytest.mark.parametrize("fixture_name", FACTORIAL_FIXTURES)
class TestFactorialValidation:
    """Factorial ANOVA validation against R's anova() and car::Anova()."""

    def test_type1_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova(
            meta["y"],
            {"A": meta["factor_A"], "B": meta["factor_B"]},
            ss_type=1,
        )
        # Match each term's SS (skip Residuals which is last in both)
        r_terms = r["type1_terms"]
        for i, term in enumerate(r_terms):
            if term == "Residuals":
                continue
            # Map R term names to our convention
            our_term = term.replace(":", ":")
            our_row = [row for row in result.table if row.term == our_term]
            assert len(our_row) == 1, f"Term {our_term} not found"
            assert_allclose(
                our_row[0].sum_sq, r["type1_ss"][i], rtol=1e-10,
                err_msg=f"Type I SS({our_term}) mismatch for {fixture_name}",
            )

    def test_type1_f_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova(
            meta["y"],
            {"A": meta["factor_A"], "B": meta["factor_B"]},
            ss_type=1,
        )
        r_terms = r["type1_terms"]
        for i, term in enumerate(r_terms):
            if term == "Residuals":
                continue
            our_row = [row for row in result.table if row.term == term][0]
            r_f = r["type1_f"][i]
            if r_f is not None:
                assert_allclose(
                    our_row.f_value, r_f, rtol=1e-10,
                    err_msg=f"Type I F({term}) mismatch for {fixture_name}",
                )

    def test_type2_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        if "type2_terms" not in r:
            pytest.skip("Type II results not available from R")
        result = anova(
            meta["y"],
            {"A": meta["factor_A"], "B": meta["factor_B"]},
            ss_type=2,
        )
        r_terms = r["type2_terms"]
        for i, term in enumerate(r_terms):
            if term == "Residuals":
                continue
            our_term = term.replace(":", ":")
            our_row = [row for row in result.table if row.term == our_term]
            if len(our_row) == 0:
                continue
            assert_allclose(
                our_row[0].sum_sq, r["type2_ss"][i], rtol=1e-10,
                err_msg=f"Type II SS({our_term}) mismatch for {fixture_name}",
            )

    def test_type3_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        if "type3_terms" not in r:
            pytest.skip("Type III results not available from R")
        result = anova(
            meta["y"],
            {"A": meta["factor_A"], "B": meta["factor_B"]},
            ss_type=3,
        )
        r_terms = r["type3_terms"]
        for i, term in enumerate(r_terms):
            if term in ("Residuals", "(Intercept)"):
                continue
            our_term = term.replace(":", ":")
            our_row = [row for row in result.table if row.term == our_term]
            if len(our_row) == 0:
                continue
            assert_allclose(
                our_row[0].sum_sq, r["type3_ss"][i], rtol=1e-8,
                err_msg=f"Type III SS({our_term}) mismatch for {fixture_name}",
            )

    def test_residual_ss_matches_r(self, fixture_name):
        meta, r = _load_fixture(fixture_name)
        result = anova(
            meta["y"],
            {"A": meta["factor_A"], "B": meta["factor_B"]},
            ss_type=1,
        )
        resid = [row for row in result.table if row.term == "Residuals"][0]
        assert_allclose(resid.sum_sq, r["residual_ss"], rtol=1e-10)


# ═══════════════════════════════════════════════════════════════════════
# ANCOVA validation
# ═══════════════════════════════════════════════════════════════════════


class TestANCOVAValidation:
    """ANCOVA validation against R's car::Anova(lm(y ~ group + x), type='II')."""

    def test_type2_ss_matches_r(self):
        meta, r = _load_fixture("ancova")
        if "type2_terms" not in r:
            pytest.skip("ANCOVA Type II results not available from R")

        result = anova(
            meta["y"],
            {"group": meta["group"]},
            covariates={"x": meta["covariate"]},
            ss_type=2,
            interactions=False,
        )

        r_terms = r["type2_terms"]
        for i, term in enumerate(r_terms):
            if term == "Residuals":
                continue
            our_row = [row for row in result.table if row.term == term]
            if len(our_row) == 0:
                continue
            assert_allclose(
                our_row[0].sum_sq, r["type2_ss"][i], rtol=1e-8,
                err_msg=f"ANCOVA Type II SS({term}) mismatch",
            )

    def test_type2_f_matches_r(self):
        meta, r = _load_fixture("ancova")
        if "type2_terms" not in r:
            pytest.skip("ANCOVA Type II results not available from R")

        result = anova(
            meta["y"],
            {"group": meta["group"]},
            covariates={"x": meta["covariate"]},
            ss_type=2,
            interactions=False,
        )

        r_terms = r["type2_terms"]
        for i, term in enumerate(r_terms):
            if term == "Residuals":
                continue
            our_row = [row for row in result.table if row.term == term]
            if len(our_row) == 0:
                continue
            r_f = r["type2_f"][i]
            if r_f is not None:
                assert_allclose(
                    our_row[0].f_value, r_f, rtol=1e-8,
                    err_msg=f"ANCOVA Type II F({term}) mismatch",
                )


# ═══════════════════════════════════════════════════════════════════════
# Levene test validation
# ═══════════════════════════════════════════════════════════════════════


class TestLeveneValidation:
    """Levene's test validation against R's car::leveneTest()."""

    def test_brown_forsythe_f_matches_r(self):
        meta, r = _load_fixture("levene")
        result = levene_test(meta["y"], meta["group"], center="median")
        assert_allclose(
            result.f_value, r["bf_f"], rtol=1e-8,
            err_msg="Brown-Forsythe F mismatch",
        )

    def test_brown_forsythe_p_matches_r(self):
        meta, r = _load_fixture("levene")
        result = levene_test(meta["y"], meta["group"], center="median")
        assert_allclose(
            result.p_value, r["bf_p"], rtol=1e-6,
            err_msg="Brown-Forsythe p mismatch",
        )

    def test_brown_forsythe_df_matches_r(self):
        meta, r = _load_fixture("levene")
        result = levene_test(meta["y"], meta["group"], center="median")
        assert result.df_between == r["bf_df1"]
        assert result.df_within == r["bf_df2"]

    def test_levene_mean_f_matches_r(self):
        meta, r = _load_fixture("levene")
        result = levene_test(meta["y"], meta["group"], center="mean")
        assert_allclose(
            result.f_value, r["levene_f"], rtol=1e-8,
            err_msg="Levene (mean) F mismatch",
        )

    def test_levene_mean_p_matches_r(self):
        meta, r = _load_fixture("levene")
        result = levene_test(meta["y"], meta["group"], center="mean")
        assert_allclose(
            result.p_value, r["levene_p"], rtol=1e-6,
            err_msg="Levene (mean) p mismatch",
        )


# ═══════════════════════════════════════════════════════════════════════
# Tukey HSD validation
# ═══════════════════════════════════════════════════════════════════════


class TestTukeyValidation:
    """Tukey HSD validation against R's TukeyHSD(aov(...))."""

    def test_diff_matches_r(self):
        meta, r = _load_fixture("tukey")
        anova_result = anova_oneway(meta["y"], meta["group"])
        posthoc = anova_posthoc(anova_result, method="tukey")

        # R comparisons are named like "B-A", "C-A", "C-B"
        r_comparisons = r["comparisons"]
        r_diff = r["diff"]

        for i, r_comp in enumerate(r_comparisons):
            # Parse "B-A" into group2="B", group1="A"
            parts = r_comp.split("-")
            g2, g1 = parts[0], parts[1]
            our_comp = [
                c for c in posthoc.comparisons
                if c.group1 == g1 and c.group2 == g2
            ]
            assert len(our_comp) == 1, f"Comparison {r_comp} not found"
            assert_allclose(
                our_comp[0].diff, r_diff[i], rtol=1e-8,
                err_msg=f"Tukey diff for {r_comp} mismatch",
            )

    def test_ci_matches_r(self):
        meta, r = _load_fixture("tukey")
        anova_result = anova_oneway(meta["y"], meta["group"])
        posthoc = anova_posthoc(anova_result, method="tukey")

        r_comparisons = r["comparisons"]
        r_lwr = r["lwr"]
        r_upr = r["upr"]

        for i, r_comp in enumerate(r_comparisons):
            parts = r_comp.split("-")
            g2, g1 = parts[0], parts[1]
            our_comp = [
                c for c in posthoc.comparisons
                if c.group1 == g1 and c.group2 == g2
            ][0]
            assert_allclose(
                our_comp.ci_lower, r_lwr[i], rtol=1e-4,
                err_msg=f"Tukey CI lower for {r_comp}",
            )
            assert_allclose(
                our_comp.ci_upper, r_upr[i], rtol=1e-4,
                err_msg=f"Tukey CI upper for {r_comp}",
            )

    def test_p_adj_matches_r(self):
        meta, r = _load_fixture("tukey")
        anova_result = anova_oneway(meta["y"], meta["group"])
        posthoc = anova_posthoc(anova_result, method="tukey")

        r_comparisons = r["comparisons"]
        r_p = r["p_adj"]

        for i, r_comp in enumerate(r_comparisons):
            parts = r_comp.split("-")
            g2, g1 = parts[0], parts[1]
            our_comp = [
                c for c in posthoc.comparisons
                if c.group1 == g1 and c.group2 == g2
            ][0]
            # Use atol=1e-10 for very small p-values (scipy underflows
            # before R's ptukey does, so both are essentially zero)
            assert_allclose(
                our_comp.p_value, r_p[i], rtol=1e-4, atol=1e-10,
                err_msg=f"Tukey p adj for {r_comp}",
            )


# ═══════════════════════════════════════════════════════════════════════
# Effect sizes validation
# ═══════════════════════════════════════════════════════════════════════


class TestEtaSquaredValidation:
    """Effect size validation against R's computed eta-squared."""

    def test_eta_squared_matches_r(self):
        meta, r = _load_fixture("eta")
        result = anova_oneway(meta["y"], meta["group"])
        assert_allclose(
            result.eta_squared["group"], r["eta_squared"], rtol=1e-10,
            err_msg="eta-squared mismatch",
        )

    def test_partial_eta_squared_matches_r(self):
        meta, r = _load_fixture("eta")
        result = anova_oneway(meta["y"], meta["group"])
        assert_allclose(
            result.partial_eta_squared["group"],
            r["partial_eta_squared"],
            rtol=1e-10,
            err_msg="partial eta-squared mismatch",
        )

    def test_ss_group_matches_r(self):
        meta, r = _load_fixture("eta")
        result = anova_oneway(meta["y"], meta["group"])
        assert_allclose(
            result.table[0].sum_sq, r["ss_group"], rtol=1e-10,
        )

    def test_ss_residual_matches_r(self):
        meta, r = _load_fixture("eta")
        result = anova_oneway(meta["y"], meta["group"])
        assert_allclose(
            result.residual_ss, r["ss_residual"], rtol=1e-10,
        )


# ═══════════════════════════════════════════════════════════════════════
# Repeated measures validation
# ═══════════════════════════════════════════════════════════════════════


class TestRMValidation:
    """Repeated-measures ANOVA validation against R's aov(... + Error(...))."""

    def test_within_ss_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        cond_row = [row for row in result.table if row.term == "condition"][0]
        assert_allclose(
            cond_row.sum_sq, r["within_ss"], rtol=1e-10,
            err_msg="RM within SS mismatch",
        )

    def test_within_df_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        cond_row = [row for row in result.table if row.term == "condition"][0]
        assert cond_row.df == r["within_df"]

    def test_within_f_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        cond_row = [row for row in result.table if row.term == "condition"][0]
        assert_allclose(
            cond_row.f_value, r["within_f"], rtol=1e-10,
            err_msg="RM within F mismatch",
        )

    def test_within_p_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        cond_row = [row for row in result.table if row.term == "condition"][0]
        assert_allclose(
            cond_row.p_value, r["within_p"], rtol=1e-8,
            err_msg="RM within p mismatch",
        )

    def test_error_ss_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        error_row = [row for row in result.table if row.term == "Error"][0]
        assert_allclose(
            error_row.sum_sq, r["error_ss"], rtol=1e-10,
            err_msg="RM error SS mismatch",
        )

    def test_error_df_matches_r(self):
        meta, r = _load_fixture("rm_within")
        result = anova_rm(
            meta["y"],
            meta["subject"],
            within={"condition": meta["condition"]},
        )
        error_row = [row for row in result.table if row.term == "Error"][0]
        assert error_row.df == r["error_df"]

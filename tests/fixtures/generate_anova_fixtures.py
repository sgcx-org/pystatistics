"""
Generate test fixtures for ANOVA validation against R.

Creates scenarios covering:
- One-way: balanced, unbalanced
- Factorial: balanced 2x3, unbalanced 2x2, interaction
- ANCOVA: one factor + one covariate
- Type I, II, III sums of squares
- Levene test: equal and unequal variances
- Tukey HSD, Bonferroni pairwise
- Repeated measures: within-only, mixed design
- Effect sizes: eta-squared, partial eta-squared

Fixture format:
    anova_{name}_meta.json      - data + call parameters
    anova_{name}_r_results.json - generated by run_r_anova_validation.R

Usage:
    python tests/fixtures/generate_anova_fixtures.py
    Rscript tests/fixtures/run_r_anova_validation.R
    pytest tests/anova/test_r_validation.py -v
"""

from __future__ import annotations

import json
from pathlib import Path

import numpy as np

FIXTURES_DIR = Path(__file__).resolve().parent


def _save_meta(name: str, meta: dict) -> None:
    """Save fixture metadata as JSON."""
    path = FIXTURES_DIR / f"anova_{name}_meta.json"
    with open(path, "w") as f:
        json.dump(meta, f, indent=2, default=_json_default)
    print(f"  Saved {path.name}")


def _json_default(obj):
    """JSON serializer for numpy types."""
    if isinstance(obj, np.ndarray):
        return obj.tolist()
    if isinstance(obj, np.integer):
        return int(obj)
    if isinstance(obj, np.floating):
        return float(obj)
    raise TypeError(f"Object of type {type(obj)} is not JSON serializable")


# ═══════════════════════════════════════════════════════════════════════
# One-way ANOVA fixtures
# ═══════════════════════════════════════════════════════════════════════


def gen_oneway_balanced():
    """3-group balanced (n=15 each), means at 10, 15, 20."""
    rng = np.random.default_rng(2024)
    n_per = 15
    y = np.concatenate([
        rng.normal(10.0, 2.0, n_per),
        rng.normal(15.0, 2.0, n_per),
        rng.normal(20.0, 2.0, n_per),
    ])
    group = ['A'] * n_per + ['B'] * n_per + ['C'] * n_per

    _save_meta("oneway_balanced", {
        "type": "oneway",
        "y": y,
        "group": group,
    })


def gen_oneway_unbalanced():
    """3-group unbalanced (n=8, 12, 20)."""
    rng = np.random.default_rng(2024)
    y = np.concatenate([
        rng.normal(10.0, 3.0, 8),
        rng.normal(14.0, 3.0, 12),
        rng.normal(18.0, 3.0, 20),
    ])
    group = ['A'] * 8 + ['B'] * 12 + ['C'] * 20

    _save_meta("oneway_unbalanced", {
        "type": "oneway",
        "y": y,
        "group": group,
    })


# ═══════════════════════════════════════════════════════════════════════
# Factorial ANOVA fixtures
# ═══════════════════════════════════════════════════════════════════════


def gen_twoway_balanced():
    """2x3 balanced (n=10 per cell), clear main effects."""
    rng = np.random.default_rng(2024)
    n_per_cell = 10
    y_list = []
    a_list = []
    b_list = []
    for a_level in ['low', 'high']:
        for b_level in ['X', 'Y', 'Z']:
            mean = 10.0
            if a_level == 'high':
                mean += 5.0
            if b_level == 'Y':
                mean += 3.0
            elif b_level == 'Z':
                mean += 6.0
            y_list.append(rng.normal(mean, 2.0, n_per_cell))
            a_list.extend([a_level] * n_per_cell)
            b_list.extend([b_level] * n_per_cell)

    _save_meta("twoway_balanced", {
        "type": "factorial",
        "y": np.concatenate(y_list),
        "factor_A": a_list,
        "factor_B": b_list,
    })


def gen_twoway_unbalanced():
    """2x2 unbalanced with interaction."""
    rng = np.random.default_rng(2024)

    cells = {
        ('A', 'X'): (10.0, 6),
        ('A', 'Y'): (12.0, 10),
        ('B', 'X'): (14.0, 8),
        ('B', 'Y'): (20.0, 12),  # strong interaction effect
    }

    y_list = []
    f1_list = []
    f2_list = []
    for (a, b), (mean, n) in cells.items():
        y_list.append(rng.normal(mean, 2.5, n))
        f1_list.extend([a] * n)
        f2_list.extend([b] * n)

    _save_meta("twoway_unbalanced", {
        "type": "factorial",
        "y": np.concatenate(y_list),
        "factor_A": f1_list,
        "factor_B": f2_list,
    })


def gen_ancova():
    """One factor + one continuous covariate."""
    rng = np.random.default_rng(2024)
    n_per = 20

    y_list = []
    group_list = []
    cov_list = []
    for level, base in [('control', 10.0), ('treatment', 16.0)]:
        x = rng.uniform(20, 60, n_per)
        y_val = base + 0.15 * x + rng.normal(0, 2, n_per)
        y_list.append(y_val)
        group_list.extend([level] * n_per)
        cov_list.append(x)

    _save_meta("ancova", {
        "type": "ancova",
        "y": np.concatenate(y_list),
        "group": group_list,
        "covariate": np.concatenate(cov_list),
    })


# ═══════════════════════════════════════════════════════════════════════
# Levene test fixture
# ═══════════════════════════════════════════════════════════════════════


def gen_levene():
    """3 groups with unequal variances."""
    rng = np.random.default_rng(2024)
    y = np.concatenate([
        rng.normal(10, 1.0, 25),
        rng.normal(10, 3.0, 25),
        rng.normal(10, 6.0, 25),
    ])
    group = ['A'] * 25 + ['B'] * 25 + ['C'] * 25

    _save_meta("levene", {
        "type": "levene",
        "y": y,
        "group": group,
    })


# ═══════════════════════════════════════════════════════════════════════
# Tukey HSD fixture
# ═══════════════════════════════════════════════════════════════════════


def gen_tukey():
    """3-group balanced for Tukey HSD."""
    rng = np.random.default_rng(2024)
    n_per = 15
    y = np.concatenate([
        rng.normal(10.0, 2.0, n_per),
        rng.normal(15.0, 2.0, n_per),
        rng.normal(20.0, 2.0, n_per),
    ])
    group = ['A'] * n_per + ['B'] * n_per + ['C'] * n_per

    _save_meta("tukey", {
        "type": "tukey",
        "y": y,
        "group": group,
    })


# ═══════════════════════════════════════════════════════════════════════
# Bonferroni fixture
# ═══════════════════════════════════════════════════════════════════════


def gen_bonferroni():
    """Same data as Tukey, for Bonferroni comparison."""
    rng = np.random.default_rng(2024)
    n_per = 15
    y = np.concatenate([
        rng.normal(10.0, 2.0, n_per),
        rng.normal(15.0, 2.0, n_per),
        rng.normal(20.0, 2.0, n_per),
    ])
    group = ['A'] * n_per + ['B'] * n_per + ['C'] * n_per

    _save_meta("bonferroni", {
        "type": "bonferroni",
        "y": y,
        "group": group,
    })


# ═══════════════════════════════════════════════════════════════════════
# Repeated measures fixture
# ═══════════════════════════════════════════════════════════════════════


def gen_rm_within():
    """12 subjects × 3 conditions (within-only)."""
    rng = np.random.default_rng(2024)
    n_subjects = 12
    conditions = ['cond_A', 'cond_B', 'cond_C']
    condition_means = [10.0, 15.0, 20.0]
    subject_effects = rng.normal(0, 3, n_subjects)

    y_list = []
    subj_list = []
    cond_list = []

    for i in range(n_subjects):
        for j, (cond_name, cond_mean) in enumerate(zip(conditions, condition_means)):
            y_val = cond_mean + subject_effects[i] + rng.normal(0, 1.5)
            y_list.append(y_val)
            subj_list.append(f"S{i+1:02d}")
            cond_list.append(cond_name)

    _save_meta("rm_within", {
        "type": "rm_within",
        "y": y_list,
        "subject": subj_list,
        "condition": cond_list,
        "n_subjects": n_subjects,
        "n_conditions": len(conditions),
    })


def gen_rm_mixed():
    """Mixed design: 2 between-groups × 3 within-conditions, 10 subjects/group."""
    rng = np.random.default_rng(2024)
    n_per_group = 10

    y_list = []
    subj_list = []
    within_list = []
    between_list = []

    subject_id = 1
    for grp, grp_effect in [('control', 0.0), ('treatment', 6.0)]:
        for _ in range(n_per_group):
            subj_effect = rng.normal(0, 3)
            for cond_mean, cond_name in [(10.0, 'T1'), (14.0, 'T2'), (18.0, 'T3')]:
                y_val = cond_mean + grp_effect + subj_effect + rng.normal(0, 1.5)
                y_list.append(y_val)
                subj_list.append(f"S{subject_id:02d}")
                within_list.append(cond_name)
                between_list.append(grp)
            subject_id += 1

    _save_meta("rm_mixed", {
        "type": "rm_mixed",
        "y": y_list,
        "subject": subj_list,
        "within": within_list,
        "between": between_list,
        "n_subjects": n_per_group * 2,
        "n_conditions": 3,
        "n_groups": 2,
    })


# ═══════════════════════════════════════════════════════════════════════
# Effect sizes fixture (uses same data as oneway_balanced)
# ═══════════════════════════════════════════════════════════════════════


def gen_eta():
    """Same as oneway_balanced for eta-squared validation."""
    rng = np.random.default_rng(2024)
    n_per = 15
    y = np.concatenate([
        rng.normal(10.0, 2.0, n_per),
        rng.normal(15.0, 2.0, n_per),
        rng.normal(20.0, 2.0, n_per),
    ])
    group = ['A'] * n_per + ['B'] * n_per + ['C'] * n_per

    _save_meta("eta", {
        "type": "eta",
        "y": y,
        "group": group,
    })


# ═══════════════════════════════════════════════════════════════════════
# Main
# ═══════════════════════════════════════════════════════════════════════


def main():
    print("Generating ANOVA fixtures...\n")

    gen_oneway_balanced()
    gen_oneway_unbalanced()
    gen_twoway_balanced()
    gen_twoway_unbalanced()
    gen_ancova()
    gen_levene()
    gen_tukey()
    gen_bonferroni()
    gen_rm_within()
    gen_rm_mixed()
    gen_eta()

    print(f"\nDone! Generated 11 fixtures in {FIXTURES_DIR}")
    print("Next: Rscript tests/fixtures/run_r_anova_validation.R")


if __name__ == "__main__":
    main()

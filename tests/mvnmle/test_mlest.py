"""
Critical R-validation tests for MVN MLE.

These tests verify that the pystatistics implementation matches R's mvnmle
package exactly (within numerical tolerance). The reference values were
generated by running R's mlest() and saved as JSON.
"""

import json
import numpy as np
import pytest
from pathlib import Path

from pystatistics.mvnmle import mlest, datasets, MVNDesign, MVNSolution

REFERENCES = Path(__file__).parent / "references"


@pytest.fixture
def apple_ref():
    with open(REFERENCES / "apple_reference.json") as f:
        return json.load(f)


@pytest.fixture
def missvals_ref():
    with open(REFERENCES / "missvals_reference.json") as f:
        return json.load(f)


# =====================================================================
# Core R-compatibility tests
# =====================================================================

class TestAppleDataset:
    """Validate apple dataset against R reference."""

    def test_convergence(self):
        result = mlest(datasets.apple, backend='cpu')
        assert result.converged

    def test_loglikelihood(self, apple_ref):
        result = mlest(datasets.apple, backend='cpu')
        expected_loglik = apple_ref['loglik']
        assert abs(result.loglik - expected_loglik) < 1e-7, (
            f"Loglik {result.loglik} differs from R {expected_loglik} "
            f"by {abs(result.loglik - expected_loglik)}"
        )

    def test_mean_estimates(self, apple_ref):
        result = mlest(datasets.apple, backend='cpu')
        expected_mu = np.array(apple_ref['muhat'])
        np.testing.assert_allclose(result.muhat, expected_mu, rtol=1e-3,
                                   err_msg="Mean estimates differ from R")

    def test_covariance_estimates(self, apple_ref):
        result = mlest(datasets.apple, backend='cpu')
        expected_sigma = np.array(apple_ref['sigmahat'])
        np.testing.assert_allclose(result.sigmahat, expected_sigma, rtol=1e-3,
                                   err_msg="Covariance estimates differ from R")

    def test_covariance_symmetric(self):
        result = mlest(datasets.apple, backend='cpu')
        np.testing.assert_allclose(
            result.sigmahat, result.sigmahat.T,
            atol=1e-14,
            err_msg="Covariance not symmetric"
        )

    def test_covariance_positive_definite(self):
        result = mlest(datasets.apple, backend='cpu')
        eigenvals = np.linalg.eigvalsh(result.sigmahat)
        assert np.all(eigenvals > 0), f"Not PD: min eigenvalue = {eigenvals.min()}"

    def test_reproducibility(self):
        r1 = mlest(datasets.apple, backend='cpu')
        r2 = mlest(datasets.apple, backend='cpu')
        np.testing.assert_allclose(r1.muhat, r2.muhat, atol=1e-14)
        np.testing.assert_allclose(r1.sigmahat, r2.sigmahat, atol=1e-14)
        assert abs(r1.loglik - r2.loglik) < 1e-14

    def test_design_wrapping(self):
        design = MVNDesign.from_array(datasets.apple)
        result = mlest(design, backend='cpu')
        assert result.converged
        assert isinstance(result, MVNSolution)

    def test_solution_properties(self):
        result = mlest(datasets.apple, backend='cpu')
        assert result.muhat.shape == (2,)
        assert result.sigmahat.shape == (2, 2)
        assert isinstance(result.loglik, float)
        assert isinstance(result.n_iter, int)
        assert result.n_iter > 0
        assert result.standard_deviations.shape == (2,)
        assert result.correlation_matrix.shape == (2, 2)
        assert np.allclose(np.diag(result.correlation_matrix), 1.0)


class TestMissvalsDataset:
    """Validate missvals dataset against R reference."""

    def test_loglikelihood(self, missvals_ref):
        result = mlest(datasets.missvals, backend='cpu', max_iter=500)
        expected_loglik = missvals_ref['loglik']
        assert abs(result.loglik - expected_loglik) < 1e-6, (
            f"Loglik {result.loglik} differs from R {expected_loglik} "
            f"by {abs(result.loglik - expected_loglik)}"
        )

    def test_mean_estimates(self, missvals_ref):
        result = mlest(datasets.missvals, backend='cpu', max_iter=500)
        expected_mu = np.array(missvals_ref['muhat'])
        np.testing.assert_allclose(result.muhat, expected_mu, rtol=5e-3,
                                   err_msg="Mean estimates differ from R")

    def test_covariance_symmetric(self):
        result = mlest(datasets.missvals, backend='cpu', max_iter=500)
        np.testing.assert_allclose(
            result.sigmahat, result.sigmahat.T,
            atol=1e-14,
            err_msg="Covariance not symmetric"
        )

    def test_covariance_positive_definite(self):
        result = mlest(datasets.missvals, backend='cpu', max_iter=500)
        eigenvals = np.linalg.eigvalsh(result.sigmahat)
        assert np.all(eigenvals > 0), f"Not PD: min eigenvalue = {eigenvals.min()}"

    def test_dimensions(self):
        result = mlest(datasets.missvals, backend='cpu', max_iter=500)
        assert result.muhat.shape == (5,)
        assert result.sigmahat.shape == (5, 5)


# =====================================================================
# Edge cases
# =====================================================================

class TestEdgeCases:
    """Test edge cases and special data configurations."""

    def test_complete_data(self):
        """No missing values should still work."""
        rng = np.random.default_rng(42)
        data = rng.multivariate_normal([0, 0], [[1, 0.5], [0.5, 1]], size=50)
        result = mlest(data, backend='cpu')
        assert result.converged
        np.testing.assert_allclose(result.muhat, [0, 0], atol=0.5)

    def test_high_missing_rate(self):
        """Should handle high missingness."""
        rng = np.random.default_rng(42)
        data = rng.multivariate_normal([5, 10], [[2, 1], [1, 3]], size=100)
        mask = rng.random(data.shape) < 0.4
        for i in range(data.shape[0]):
            if mask[i].all():
                mask[i, 0] = False
        for j in range(data.shape[1]):
            if mask[:, j].all():
                mask[0, j] = False
        data[mask] = np.nan
        result = mlest(data, backend='cpu', max_iter=200)
        assert np.all(np.isfinite(result.muhat))
        assert np.all(np.isfinite(result.sigmahat))

    def test_monotone_pattern(self):
        """Should handle monotone missingness."""
        rng = np.random.default_rng(42)
        data = rng.multivariate_normal([0, 0, 0], np.eye(3), size=30)
        data[15:, 2] = np.nan
        data[20:, 1] = np.nan
        result = mlest(data, backend='cpu')
        assert np.all(np.isfinite(result.muhat))

    def test_two_variables(self):
        """Minimum viable: 2 variables."""
        rng = np.random.default_rng(42)
        data = rng.multivariate_normal([0, 0], [[1, 0.5], [0.5, 1]], size=20)
        data[15:, 1] = np.nan
        result = mlest(data, backend='cpu')
        assert result.muhat.shape == (2,)


# =====================================================================
# Solution interface
# =====================================================================

class TestSolutionInterface:
    """Test MVNSolution computed properties."""

    def test_aic_bic(self):
        result = mlest(datasets.apple, backend='cpu')
        p = 2
        k = p + p * (p + 1) // 2
        expected_aic = -2 * result.loglik + 2 * k
        assert abs(result.aic - expected_aic) < 1e-10

    def test_summary_string(self):
        result = mlest(datasets.apple, backend='cpu')
        summary = result.summary()
        assert "MVN MLE Results" in summary
        assert "Converged: True" in summary
        assert "Log-likelihood" in summary

    def test_to_dict(self):
        result = mlest(datasets.apple, backend='cpu')
        d = result.to_dict()
        assert 'muhat' in d
        assert 'sigmahat' in d
        assert 'loglik' in d
        assert 'converged' in d

    def test_timing(self):
        result = mlest(datasets.apple, backend='cpu')
        assert result.timing is not None
        assert 'total_seconds' in result.timing
        assert result.timing['total_seconds'] > 0

    def test_backend_name(self):
        result = mlest(datasets.apple, backend='cpu')
        assert 'cpu' in result.backend_name
